<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bobble - æ³¡æ³¡å°„æ“ŠéŠæˆ²</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 480px;
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .score-display, .level-display {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
        }

        .score-value, .level-value {
            color: #ffd700;
            font-size: 24px;
        }

        .game-wrapper {
            position: relative;
            background: linear-gradient(180deg, #1e3a5f 0%, #0d1b2a 100%);
            border-radius: 20px;
            padding: 10px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #gameCanvas {
            display: block;
            border-radius: 15px;
            cursor: crosshair;
        }

        .controls {
            display: flex;
            gap: 15px;
        }

        .btn {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        .next-bubble {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #fff;
            font-size: 14px;
        }

        #nextBubblePreview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border-radius: 15px;
            gap: 20px;
        }

        .game-over-overlay.show {
            display: flex;
        }

        .game-over-text {
            color: #fff;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .final-score {
            color: #ffd700;
            font-size: 24px;
        }

        .instructions {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            max-width: 480px;
        }

        .high-score-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            width: 480px;
            padding: 10px 25px;
            background: rgba(255, 215, 0, 0.15);
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .high-score-display {
            color: #ffd700;
            font-size: 16px;
            font-weight: bold;
        }

        .high-score-value {
            color: #fff;
            font-size: 20px;
        }

        /* æ’è¡Œæ¦œå½ˆçª— */
        .leaderboard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .leaderboard-overlay.show {
            display: flex;
        }

        .leaderboard-panel {
            background: linear-gradient(180deg, #1e3a5f 0%, #0d1b2a 100%);
            border-radius: 20px;
            padding: 30px;
            min-width: 350px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5),
                        0 0 30px rgba(255, 215, 0, 0.2);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .leaderboard-title {
            color: #ffd700;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0 0 20px 0;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .leaderboard-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .leaderboard-item.top-3 {
            background: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .leaderboard-item.new-record {
            animation: newRecord 0.5s ease infinite alternate;
        }

        @keyframes newRecord {
            from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }

        .leaderboard-rank {
            font-size: 18px;
            font-weight: bold;
            width: 40px;
        }

        .leaderboard-rank.gold { color: #ffd700; }
        .leaderboard-rank.silver { color: #c0c0c0; }
        .leaderboard-rank.bronze { color: #cd7f32; }
        .leaderboard-rank.normal { color: #888; }

        .leaderboard-info {
            flex: 1;
            margin-left: 10px;
        }

        .leaderboard-name {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
        }

        .leaderboard-date {
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
        }

        .leaderboard-score {
            color: #ffd700;
            font-size: 20px;
            font-weight: bold;
        }

        .leaderboard-empty {
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            padding: 30px;
            font-style: italic;
        }

        .leaderboard-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .new-record-badge {
            color: #ffd700;
            font-size: 18px;
            text-align: center;
            margin-bottom: 15px;
            animation: pulse 1s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        /* è¼¸å…¥åå­—å½ˆçª— */
        .name-input-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }

        .name-input-overlay.show {
            display: flex;
        }

        .name-input-panel {
            background: linear-gradient(180deg, #1e3a5f 0%, #0d1b2a 100%);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .name-input-title {
            color: #ffd700;
            font-size: 24px;
            margin-bottom: 10px;
        }

        .name-input-score {
            color: #fff;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .name-input-field {
            width: 200px;
            padding: 12px 15px;
            font-size: 18px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            text-align: center;
            outline: none;
            margin-bottom: 20px;
        }

        .name-input-field:focus {
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .name-input-field::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- æœ€é«˜åˆ†é¡¯ç¤º -->
        <div class="high-score-bar">
            <div class="high-score-display">
                æœ€é«˜åˆ†: <span class="high-score-value" id="highScore">0</span>
            </div>
            <button class="btn btn-secondary" style="padding: 8px 20px; font-size: 14px;" onclick="showLeaderboard()">æ’è¡Œæ¦œ</button>
        </div>

        <div class="header">
            <div class="score-display">
                åˆ†æ•¸: <span class="score-value" id="score">0</span>
            </div>
            <div class="next-bubble">
                ä¸‹ä¸€å€‹: <canvas id="nextBubblePreview"></canvas>
            </div>
            <div class="level-display">
                é—œå¡: <span class="level-value" id="level">1</span> / 5
            </div>
        </div>

        <div class="game-wrapper">
            <canvas id="gameCanvas" width="480" height="600"></canvas>
            <div class="game-over-overlay" id="gameOverOverlay">
                <div class="game-over-text" id="gameOverText">éŠæˆ²çµæŸ!</div>
                <div class="final-score" id="finalScore">æœ€çµ‚åˆ†æ•¸: 0</div>
                <button class="btn btn-primary" onclick="game.restart()">é‡æ–°é–‹å§‹</button>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="game.restart()">é‡æ–°é–‹å§‹</button>
            <button class="btn btn-secondary" onclick="game.togglePause()">æš«åœ</button>
            <button class="btn btn-secondary" id="soundBtn" onclick="toggleSound()">éŸ³æ•ˆ: é–‹</button>
        </div>

        <div class="instructions">
            ç§»å‹•æ»‘é¼ ç„æº–ï¼Œé»æ“Šç™¼å°„æ³¡æ³¡ã€‚ä¸‰å€‹ä»¥ä¸ŠåŒè‰²æ³¡æ³¡é€£åœ¨ä¸€èµ·å³å¯æ¶ˆé™¤ï¼
        </div>
    </div>

    <!-- æ’è¡Œæ¦œå½ˆçª— -->
    <div class="leaderboard-overlay" id="leaderboardOverlay">
        <div class="leaderboard-panel">
            <div class="leaderboard-title">æ’è¡Œæ¦œ</div>
            <ul class="leaderboard-list" id="leaderboardList">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </ul>
            <div class="leaderboard-buttons">
                <button class="btn btn-primary" onclick="hideLeaderboard()">é—œé–‰</button>
                <button class="btn btn-secondary" onclick="clearLeaderboard()">æ¸…é™¤ç´€éŒ„</button>
            </div>
        </div>
    </div>

    <!-- è¼¸å…¥åå­—å½ˆçª— -->
    <div class="name-input-overlay" id="nameInputOverlay">
        <div class="name-input-panel">
            <div class="name-input-title">æ–°ç´€éŒ„ï¼</div>
            <div class="name-input-score" id="nameInputScore">åˆ†æ•¸: 0</div>
            <input type="text" class="name-input-field" id="playerNameInput" placeholder="è¼¸å…¥ä½ çš„åå­—" maxlength="10">
            <div>
                <button class="btn btn-primary" onclick="submitScore()">ç¢ºèª</button>
            </div>
        </div>
    </div>

    <script>
        // ===== æ’è¡Œæ¦œç³»çµ± =====
        class Leaderboard {
            constructor() {
                this.storageKey = 'bobble_leaderboard';
                this.maxEntries = 10;
                this.scores = this.load();
                this.pendingScore = null;
            }

            load() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : [];
                } catch (e) {
                    return [];
                }
            }

            save() {
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(this.scores));
                } catch (e) {
                    console.log('ç„¡æ³•å„²å­˜æ’è¡Œæ¦œ');
                }
            }

            getHighScore() {
                return this.scores.length > 0 ? this.scores[0].score : 0;
            }

            isHighScore(score) {
                if (score <= 0) return false;
                if (this.scores.length < this.maxEntries) return true;
                return score > this.scores[this.scores.length - 1].score;
            }

            getRank(score) {
                for (let i = 0; i < this.scores.length; i++) {
                    if (score > this.scores[i].score) {
                        return i + 1;
                    }
                }
                return this.scores.length + 1;
            }

            addScore(name, score, level) {
                const entry = {
                    name: name || 'åŒ¿åç©å®¶',
                    score: score,
                    level: level,
                    date: new Date().toLocaleDateString('zh-TW')
                };

                this.scores.push(entry);
                this.scores.sort((a, b) => b.score - a.score);
                this.scores = this.scores.slice(0, this.maxEntries);
                this.save();

                return this.scores.indexOf(entry);
            }

            clear() {
                this.scores = [];
                this.save();
            }

            getScores() {
                return this.scores;
            }
        }

        // æ’è¡Œæ¦œå¯¦ä¾‹
        const leaderboard = new Leaderboard();

        // é¡¯ç¤ºæ’è¡Œæ¦œ
        function showLeaderboard(highlightIndex = -1) {
            const overlay = document.getElementById('leaderboardOverlay');
            const list = document.getElementById('leaderboardList');

            const scores = leaderboard.getScores();

            if (scores.length === 0) {
                list.innerHTML = '<div class="leaderboard-empty">é‚„æ²’æœ‰ä»»ä½•ç´€éŒ„ï¼Œé–‹å§‹éŠæˆ²å§ï¼</div>';
            } else {
                list.innerHTML = scores.map((entry, index) => {
                    const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : 'normal';
                    const topClass = index < 3 ? 'top-3' : '';
                    const newClass = index === highlightIndex ? 'new-record' : '';
                    const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `#${index + 1}`;

                    return `
                        <li class="leaderboard-item ${topClass} ${newClass}">
                            <span class="leaderboard-rank ${rankClass}">${medal}</span>
                            <div class="leaderboard-info">
                                <div class="leaderboard-name">${entry.name}</div>
                                <div class="leaderboard-date">Lv.${entry.level} Â· ${entry.date}</div>
                            </div>
                            <span class="leaderboard-score">${entry.score}</span>
                        </li>
                    `;
                }).join('');
            }

            overlay.classList.add('show');
        }

        // éš±è—æ’è¡Œæ¦œ
        function hideLeaderboard() {
            document.getElementById('leaderboardOverlay').classList.remove('show');
        }

        // æ¸…é™¤æ’è¡Œæ¦œ
        function clearLeaderboard() {
            if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ’è¡Œæ¦œç´€éŒ„å—ï¼Ÿ')) {
                leaderboard.clear();
                updateHighScoreDisplay();
                showLeaderboard();
            }
        }

        // é¡¯ç¤ºåå­—è¼¸å…¥
        function showNameInput(score) {
            leaderboard.pendingScore = score;
            document.getElementById('nameInputScore').textContent = `åˆ†æ•¸: ${score}`;
            document.getElementById('playerNameInput').value = '';
            document.getElementById('nameInputOverlay').classList.add('show');
            document.getElementById('playerNameInput').focus();
        }

        // æäº¤åˆ†æ•¸
        function submitScore() {
            const name = document.getElementById('playerNameInput').value.trim() || 'åŒ¿åç©å®¶';
            const score = leaderboard.pendingScore;

            if (score !== null) {
                const rank = leaderboard.addScore(name, score, game.level);
                updateHighScoreDisplay();
                document.getElementById('nameInputOverlay').classList.remove('show');
                showLeaderboard(rank);
                leaderboard.pendingScore = null;
            }
        }

        // æ›´æ–°æœ€é«˜åˆ†é¡¯ç¤º
        function updateHighScoreDisplay() {
            document.getElementById('highScore').textContent = leaderboard.getHighScore();
        }

        // Enter éµæäº¤
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && document.getElementById('nameInputOverlay').classList.contains('show')) {
                submitScore();
            }
            if (e.key === 'Escape') {
                hideLeaderboard();
            }
        });

        // ===== éŸ³æ•ˆç³»çµ± =====
        class SoundManager {
            constructor() {
                this.audioContext = null;
                this.enabled = true;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (e) {
                    console.log('Web Audio API not supported');
                    this.enabled = false;
                }
            }

            // ç™¼å°„éŸ³æ•ˆ
            playShoot() {
                if (!this.enabled || !this.audioContext) return;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();

                osc.connect(gain);
                gain.connect(this.audioContext.destination);

                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.1);

                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 0.15);
            }

            // ç¢°æ’/é™„è‘—éŸ³æ•ˆ
            playAttach() {
                if (!this.enabled || !this.audioContext) return;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();

                osc.connect(gain);
                gain.connect(this.audioContext.destination);

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);

                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);

                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 0.1);
            }

            // ç‰†å£åå½ˆéŸ³æ•ˆ
            playBounce() {
                if (!this.enabled || !this.audioContext) return;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();

                osc.connect(gain);
                gain.connect(this.audioContext.destination);

                osc.type = 'square';
                osc.frequency.setValueAtTime(150, this.audioContext.currentTime);

                gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);

                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 0.05);
            }

            // æ¶ˆé™¤éŸ³æ•ˆ (é€£çºŒéŸ³ç¬¦)
            playPop(count = 1) {
                if (!this.enabled || !this.audioContext) return;

                const baseFreq = 523.25; // C5
                const notes = [1, 1.25, 1.5, 1.75, 2]; // éŸ³éšæ¯”ä¾‹

                for (let i = 0; i < Math.min(count, 5); i++) {
                    setTimeout(() => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);

                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(baseFreq * notes[i], this.audioContext.currentTime);

                        gain.gain.setValueAtTime(0.25, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                        osc.start(this.audioContext.currentTime);
                        osc.stop(this.audioContext.currentTime + 0.15);
                    }, i * 50);
                }
            }

            // æ‰è½éŸ³æ•ˆ
            playDrop(count = 1) {
                if (!this.enabled || !this.audioContext) return;

                for (let i = 0; i < Math.min(count, 3); i++) {
                    setTimeout(() => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);

                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(800 - i * 100, this.audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.3);

                        gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                        osc.start(this.audioContext.currentTime);
                        osc.stop(this.audioContext.currentTime + 0.3);
                    }, i * 100);
                }
            }

            // éŠæˆ²çµæŸéŸ³æ•ˆ
            playGameOver() {
                if (!this.enabled || !this.audioContext) return;

                const notes = [400, 350, 300, 250];
                notes.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);

                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);

                        gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                        osc.start(this.audioContext.currentTime);
                        osc.stop(this.audioContext.currentTime + 0.3);
                    }, i * 200);
                });
            }

            // å‡ç´šéŸ³æ•ˆ
            playLevelUp() {
                if (!this.enabled || !this.audioContext) return;

                const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                notes.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);

                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);

                        gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);

                        osc.start(this.audioContext.currentTime);
                        osc.stop(this.audioContext.currentTime + 0.2);
                    }, i * 100);
                });
            }

            toggle() {
                this.enabled = !this.enabled;
                return this.enabled;
            }
        }

        // ===== ç²’å­ç³»çµ± =====
        class Particle {
            constructor(x, y, color, type = 'explode') {
                this.x = x;
                this.y = y;
                this.color = color;
                this.type = type;

                if (type === 'explode') {
                    // çˆ†ç‚¸ç²’å­ - å‘å››å‘¨æ“´æ•£
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 4;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.radius = 3 + Math.random() * 5;
                    this.life = 1;
                    this.decay = 0.02 + Math.random() * 0.02;
                    this.gravity = 0.1;
                } else if (type === 'drop') {
                    // æ‰è½ç²’å­ - å‘ä¸‹æ‰è½
                    this.vx = (Math.random() - 0.5) * 3;
                    this.vy = 2 + Math.random() * 3;
                    this.radius = 4 + Math.random() * 6;
                    this.life = 1;
                    this.decay = 0.015;
                    this.gravity = 0.3;
                } else if (type === 'sparkle') {
                    // é–ƒçˆç²’å­ - å°æ˜Ÿæ˜Ÿæ•ˆæœ
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.radius = 2 + Math.random() * 3;
                    this.life = 1;
                    this.decay = 0.03 + Math.random() * 0.02;
                    this.gravity = 0;
                } else if (type === 'confetti') {
                    // æ…¶ç¥ç´™ç‰‡ - å¾ä¸Šæ–¹é£„è½
                    this.vx = (Math.random() - 0.5) * 6;
                    this.vy = -8 - Math.random() * 6;
                    this.radius = 6 + Math.random() * 6;
                    this.life = 1;
                    this.decay = 0.005;
                    this.gravity = 0.15;
                    this.width = 8 + Math.random() * 8;
                    this.height = 6 + Math.random() * 6;
                } else if (type === 'firework') {
                    // ç…™ç«ç²’å­
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3 + Math.random() * 5;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed - 2;
                    this.radius = 3 + Math.random() * 4;
                    this.life = 1;
                    this.decay = 0.015 + Math.random() * 0.01;
                    this.gravity = 0.08;
                    this.trail = [];
                }

                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= this.decay;
                this.rotation += this.rotationSpeed;
                this.radius *= 0.98;
                return this.life > 0 && this.radius > 0.5;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                if (this.type === 'sparkle') {
                    // æ˜Ÿæ˜Ÿå½¢ç‹€
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const r = i % 2 === 0 ? this.radius : this.radius * 0.4;
                        ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'confetti') {
                    // ç´™ç‰‡å½¢ç‹€ - é•·æ–¹å½¢æ—‹è½‰
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    // åŠ ä¸€é»å…‰æ¾¤
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width / 2, this.height / 2);
                } else if (this.type === 'firework') {
                    // ç…™ç«ç²’å­ - å¸¶æ‹–å°¾çš„åœ“å½¢
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, this.color);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // åœ“å½¢ç²’å­å¸¶æ¼¸å±¤
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
                    gradient.addColorStop(0, this.color);
                    gradient.addColorStop(0.5, this.color);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            // æ³¡æ³¡çˆ†ç‚¸æ•ˆæœ
            explode(x, y, color, count = 12) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y, color, 'explode'));
                }
                // æ·»åŠ ä¸€äº›ç™½è‰²é–ƒçˆ
                for (let i = 0; i < 5; i++) {
                    this.particles.push(new Particle(x, y, '#ffffff', 'sparkle'));
                }
            }

            // æ³¡æ³¡æ‰è½æ•ˆæœ
            drop(x, y, color, count = 8) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y, color, 'drop'));
                }
            }

            // é€£é–çˆ†ç‚¸æ•ˆæœï¼ˆå¤šå€‹æ³¡æ³¡åŒæ™‚çˆ†ç‚¸ï¼‰
            chainExplode(bubbles, delay = 30) {
                bubbles.forEach((bubble, index) => {
                    setTimeout(() => {
                        this.explode(bubble.x, bubble.y, bubble.color, 15);
                    }, index * delay);
                });
            }

            // é€šé—œæ…¶ç¥æ•ˆæœ
            celebrate(canvasWidth, canvasHeight) {
                const colors = ['#E74C3C', '#F1C40F', '#27AE60', '#3498DB', '#9B59B6', '#E91E63', '#FF9800'];

                // æŒçºŒç”¢ç”Ÿç…™ç«å’Œç´™ç‰‡æ•ˆæœ
                const createBurst = (delay) => {
                    setTimeout(() => {
                        // éš¨æ©Ÿä½ç½®çš„ç…™ç«çˆ†ç‚¸
                        const x = 50 + Math.random() * (canvasWidth - 100);
                        const y = 100 + Math.random() * 200;
                        const color = colors[Math.floor(Math.random() * colors.length)];

                        // ç…™ç«ç²’å­
                        for (let i = 0; i < 25; i++) {
                            this.particles.push(new Particle(x, y, color, 'firework'));
                        }
                        // é–ƒçˆæ˜Ÿæ˜Ÿ
                        for (let i = 0; i < 10; i++) {
                            this.particles.push(new Particle(x, y, '#ffffff', 'sparkle'));
                        }
                    }, delay);
                };

                // ç´™ç‰‡å¾ä¸Šæ–¹é£„è½
                const createConfetti = (delay) => {
                    setTimeout(() => {
                        for (let i = 0; i < 8; i++) {
                            const x = Math.random() * canvasWidth;
                            const y = Math.random() * 100;
                            const color = colors[Math.floor(Math.random() * colors.length)];
                            this.particles.push(new Particle(x, y, color, 'confetti'));
                        }
                    }, delay);
                };

                // ç”¢ç”Ÿå¤šæ³¢ç…™ç«
                for (let i = 0; i < 8; i++) {
                    createBurst(i * 300);
                }

                // æŒçºŒç”¢ç”Ÿç´™ç‰‡
                for (let i = 0; i < 20; i++) {
                    createConfetti(i * 150);
                }
            }

            update() {
                this.particles = this.particles.filter(p => p.update());
            }

            draw(ctx) {
                this.particles.forEach(p => p.draw(ctx));
            }

            clear() {
                this.particles = [];
            }
        }

        // æ³¡æ³¡é¡è‰²é…ç½®ï¼ˆ4è‰² - è¼ƒç°¡å–®ï¼‰
        const BUBBLE_COLORS = [
            '#E74C3C', // ç´…è‰²
            '#F1C40F', // é»ƒè‰²
            '#27AE60', // ç¶ è‰²
            '#3498DB', // è—è‰²
        ];

        // éŠæˆ²é…ç½®
        const CONFIG = {
            bubbleRadius: 20,
            rows: 10,
            cols: 12,
            shooterY: 560,
            minMatchCount: 3,
            pointsPerBubble: 10,
            pointsPerDrop: 20,
            maxLevel: 5,  // æœ€å¤§é—œå¡æ•¸
            shootSpeed: 22,  // ç™¼å°„é€Ÿåº¦ï¼ˆåŸæœ¬15ï¼‰
        };

        class Bubble {
            constructor(x, y, color, row = -1, col = -1) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = CONFIG.bubbleRadius;
                this.row = row;
                this.col = col;
                this.vx = 0;
                this.vy = 0;
                this.isMoving = false;
            }

            draw(ctx) {
                // æ³¡æ³¡ä¸»é«”
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3,
                    this.y - this.radius * 0.3,
                    0,
                    this.x,
                    this.y,
                    this.radius
                );
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.3, this.color);
                gradient.addColorStop(1, this.darkenColor(this.color, 30));

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // é«˜å…‰æ•ˆæœ
                ctx.beginPath();
                ctx.arc(
                    this.x - this.radius * 0.3,
                    this.y - this.radius * 0.3,
                    this.radius * 0.2,
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();
            }

            darkenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.max((num >> 16) - amt, 0);
                const G = Math.max(((num >> 8) & 0x00ff) - amt, 0);
                const B = Math.max((num & 0x0000ff) - amt, 0);
                return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
            }

            update() {
                if (this.isMoving) {
                    this.x += this.vx;
                    this.y += this.vy;
                }
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.previewCanvas = document.getElementById('nextBubblePreview');
                this.previewCtx = this.previewCanvas.getContext('2d');

                this.grid = [];
                this.currentBubble = null;
                this.nextBubble = null;
                this.score = 0;
                this.level = 1;
                this.isPaused = false;
                this.isGameOver = false;
                this.aimAngle = -Math.PI / 2;

                this.offsetX = (this.canvas.width - CONFIG.cols * CONFIG.bubbleRadius * 2) / 2 + CONFIG.bubbleRadius;

                // åˆå§‹åŒ–éŸ³æ•ˆå’Œç²’å­ç³»çµ±
                this.sound = new SoundManager();
                this.particles = new ParticleSystem();

                this.init();
                this.setupEventListeners();
                this.gameLoop();
            }

            init() {
                this.grid = [];
                this.score = 0;
                this.level = 1;
                this.isGameOver = false;
                this.isPaused = false;

                // æ¸…é™¤ç²’å­
                this.particles.clear();

                document.getElementById('score').textContent = '0';
                document.getElementById('level').textContent = '1';
                document.getElementById('gameOverOverlay').classList.remove('show');

                // åˆå§‹åŒ–æ³¡æ³¡ç¶²æ ¼
                const initialRows = 3;  // æ¸›å°‘åˆå§‹è¡Œæ•¸ï¼ˆåŸæœ¬5ï¼‰
                for (let row = 0; row < CONFIG.rows; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < CONFIG.cols; col++) {
                        if (row < initialRows) {
                            // åˆ¤æ–·åç§»è¡Œ
                            const isOffsetRow = row % 2 === 1;
                            const maxCols = isOffsetRow ? CONFIG.cols - 1 : CONFIG.cols;

                            if (col < maxCols) {
                                const pos = this.getPositionFromGrid(row, col);
                                const color = BUBBLE_COLORS[Math.floor(Math.random() * BUBBLE_COLORS.length)];
                                this.grid[row][col] = new Bubble(pos.x, pos.y, color, row, col);
                            } else {
                                this.grid[row][col] = null;
                            }
                        } else {
                            this.grid[row][col] = null;
                        }
                    }
                }

                this.nextBubble = this.createRandomBubble();
                this.loadNextBubble();
            }

            getPositionFromGrid(row, col) {
                const isOffsetRow = row % 2 === 1;
                const offset = isOffsetRow ? CONFIG.bubbleRadius : 0;
                return {
                    x: this.offsetX + col * CONFIG.bubbleRadius * 2 + offset,
                    y: CONFIG.bubbleRadius + row * CONFIG.bubbleRadius * 1.73
                };
            }

            getGridFromPosition(x, y) {
                const row = Math.round((y - CONFIG.bubbleRadius) / (CONFIG.bubbleRadius * 1.73));
                const isOffsetRow = row % 2 === 1;
                const offset = isOffsetRow ? CONFIG.bubbleRadius : 0;
                const col = Math.round((x - this.offsetX - offset) / (CONFIG.bubbleRadius * 2));
                return { row, col };
            }

            createRandomBubble() {
                const color = BUBBLE_COLORS[Math.floor(Math.random() * BUBBLE_COLORS.length)];
                return new Bubble(this.canvas.width / 2, CONFIG.shooterY, color);
            }

            loadNextBubble() {
                this.currentBubble = this.nextBubble;
                this.currentBubble.x = this.canvas.width / 2;
                this.currentBubble.y = CONFIG.shooterY;
                this.currentBubble.isMoving = false;
                this.currentBubble.vx = 0;
                this.currentBubble.vy = 0;

                this.nextBubble = this.createRandomBubble();
                this.drawNextBubblePreview();
            }

            drawNextBubblePreview() {
                this.previewCtx.clearRect(0, 0, 40, 40);
                const previewBubble = new Bubble(20, 20, this.nextBubble.color);
                previewBubble.radius = 16;
                previewBubble.draw(this.previewCtx);
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isPaused || this.isGameOver) return;
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const dx = mouseX - this.canvas.width / 2;
                    const dy = mouseY - CONFIG.shooterY;

                    this.aimAngle = Math.atan2(dy, dx);
                    // é™åˆ¶è§’åº¦ç¯„åœ
                    if (this.aimAngle > -0.1) this.aimAngle = -0.1;
                    if (this.aimAngle < -Math.PI + 0.1) this.aimAngle = -Math.PI + 0.1;
                });

                this.canvas.addEventListener('click', () => {
                    if (this.isPaused || this.isGameOver) return;
                    // åˆå§‹åŒ–éŸ³æ•ˆï¼ˆéœ€è¦ç”¨æˆ¶äº’å‹•æ‰èƒ½å•Ÿå‹•ï¼‰
                    this.sound.init();
                    this.shoot();
                });
            }

            shoot() {
                if (this.currentBubble.isMoving) return;

                const speed = CONFIG.shootSpeed;
                this.currentBubble.vx = Math.cos(this.aimAngle) * speed;
                this.currentBubble.vy = Math.sin(this.aimAngle) * speed;
                this.currentBubble.isMoving = true;

                // æ’­æ”¾ç™¼å°„éŸ³æ•ˆ
                this.sound.playShoot();
            }

            update() {
                if (this.isPaused || this.isGameOver) return;

                if (this.currentBubble && this.currentBubble.isMoving) {
                    this.currentBubble.update();

                    // é‚Šç•Œåå½ˆ
                    if (this.currentBubble.x <= CONFIG.bubbleRadius) {
                        this.currentBubble.x = CONFIG.bubbleRadius;
                        this.currentBubble.vx *= -1;
                        this.sound.playBounce();
                    }
                    if (this.currentBubble.x >= this.canvas.width - CONFIG.bubbleRadius) {
                        this.currentBubble.x = this.canvas.width - CONFIG.bubbleRadius;
                        this.currentBubble.vx *= -1;
                        this.sound.playBounce();
                    }

                    // é ‚éƒ¨ç¢°æ’
                    if (this.currentBubble.y <= CONFIG.bubbleRadius) {
                        this.currentBubble.y = CONFIG.bubbleRadius;
                        this.snapBubbleToGrid();
                        return;
                    }

                    // èˆ‡å…¶ä»–æ³¡æ³¡ç¢°æ’æª¢æ¸¬
                    for (let row = 0; row < CONFIG.rows; row++) {
                        for (let col = 0; col < CONFIG.cols; col++) {
                            const bubble = this.grid[row][col];
                            if (bubble) {
                                const dx = this.currentBubble.x - bubble.x;
                                const dy = this.currentBubble.y - bubble.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                if (distance < CONFIG.bubbleRadius * 2) {
                                    this.snapBubbleToGrid();
                                    return;
                                }
                            }
                        }
                    }
                }
            }

            snapBubbleToGrid() {
                const gridPos = this.getGridFromPosition(this.currentBubble.x, this.currentBubble.y);
                let { row, col } = gridPos;

                // ç¢ºä¿åœ¨æœ‰æ•ˆç¯„åœå…§
                row = Math.max(0, Math.min(row, CONFIG.rows - 1));
                const isOffsetRow = row % 2 === 1;
                const maxCol = isOffsetRow ? CONFIG.cols - 2 : CONFIG.cols - 1;
                col = Math.max(0, Math.min(col, maxCol));

                // å¦‚æœä½ç½®å·²è¢«ä½”ç”¨ï¼Œæ‰¾æœ€è¿‘çš„ç©ºä½
                if (this.grid[row] && this.grid[row][col]) {
                    const neighbors = this.getEmptyNeighbors(row, col);
                    if (neighbors.length > 0) {
                        // æ‰¾æœ€è¿‘çš„ç©ºä½
                        let minDist = Infinity;
                        let closest = neighbors[0];
                        for (const n of neighbors) {
                            const pos = this.getPositionFromGrid(n.row, n.col);
                            const dx = pos.x - this.currentBubble.x;
                            const dy = pos.y - this.currentBubble.y;
                            const dist = dx * dx + dy * dy;
                            if (dist < minDist) {
                                minDist = dist;
                                closest = n;
                            }
                        }
                        row = closest.row;
                        col = closest.col;
                    }
                }

                // ç¢ºä¿ grid[row] å­˜åœ¨
                if (!this.grid[row]) {
                    this.grid[row] = [];
                }

                const pos = this.getPositionFromGrid(row, col);
                this.currentBubble.x = pos.x;
                this.currentBubble.y = pos.y;
                this.currentBubble.row = row;
                this.currentBubble.col = col;
                this.currentBubble.isMoving = false;
                this.currentBubble.vx = 0;
                this.currentBubble.vy = 0;

                this.grid[row][col] = this.currentBubble;

                // æ’­æ”¾é™„è‘—éŸ³æ•ˆ
                this.sound.playAttach();

                // æª¢æŸ¥åŒ¹é…
                this.checkMatches(row, col);

                // æª¢æŸ¥éŠæˆ²çµæŸ
                if (row >= CONFIG.rows - 2) {
                    this.gameOver(false);
                    return;
                }

                // è¼‰å…¥ä¸‹ä¸€å€‹æ³¡æ³¡
                this.loadNextBubble();
            }

            getEmptyNeighbors(row, col) {
                const neighbors = [];
                const isOffsetRow = row % 2 === 1;

                const directions = isOffsetRow
                    ? [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]]
                    : [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]];

                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;

                    if (newRow >= 0 && newRow < CONFIG.rows && newCol >= 0) {
                        const isNewOffsetRow = newRow % 2 === 1;
                        const maxCol = isNewOffsetRow ? CONFIG.cols - 2 : CONFIG.cols - 1;

                        if (newCol <= maxCol) {
                            if (!this.grid[newRow] || !this.grid[newRow][newCol]) {
                                neighbors.push({ row: newRow, col: newCol });
                            }
                        }
                    }
                }

                return neighbors;
            }

            getNeighbors(row, col) {
                const neighbors = [];
                const isOffsetRow = row % 2 === 1;

                const directions = isOffsetRow
                    ? [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]]
                    : [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]];

                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;

                    if (newRow >= 0 && newRow < CONFIG.rows && newCol >= 0 && newCol < CONFIG.cols) {
                        if (this.grid[newRow] && this.grid[newRow][newCol]) {
                            neighbors.push({ row: newRow, col: newCol, bubble: this.grid[newRow][newCol] });
                        }
                    }
                }

                return neighbors;
            }

            checkMatches(startRow, startCol) {
                const targetColor = this.grid[startRow][startCol].color;
                const matched = [];
                const visited = new Set();

                // BFS æ‰¾åŒè‰²ç›¸é€£æ³¡æ³¡
                const queue = [{ row: startRow, col: startCol }];
                visited.add(`${startRow},${startCol}`);

                while (queue.length > 0) {
                    const current = queue.shift();
                    matched.push(current);

                    const neighbors = this.getNeighbors(current.row, current.col);
                    for (const neighbor of neighbors) {
                        const key = `${neighbor.row},${neighbor.col}`;
                        if (!visited.has(key) && neighbor.bubble.color === targetColor) {
                            visited.add(key);
                            queue.push({ row: neighbor.row, col: neighbor.col });
                        }
                    }
                }

                // å¦‚æœåŒ¹é…æ•¸é‡é”æ¨™ï¼Œæ¶ˆé™¤æ³¡æ³¡
                if (matched.length >= CONFIG.minMatchCount) {
                    // æ”¶é›†è¦çˆ†ç ´çš„æ³¡æ³¡è³‡è¨Š
                    const bubblesInfo = matched.map(({ row, col }) => ({
                        x: this.grid[row][col].x,
                        y: this.grid[row][col].y,
                        color: this.grid[row][col].color
                    }));

                    // æ¸…é™¤æ³¡æ³¡
                    for (const { row, col } of matched) {
                        this.grid[row][col] = null;
                    }

                    // æ’­æ”¾æ¶ˆé™¤éŸ³æ•ˆå’Œçˆ†ç ´å‹•ç•«
                    this.sound.playPop(matched.length);
                    this.particles.chainExplode(bubblesInfo, 40);

                    this.score += matched.length * CONFIG.pointsPerBubble;

                    // ç§»é™¤æ‡¸ç©ºæ³¡æ³¡
                    const dropped = this.removeFloatingBubbles();
                    this.score += dropped * CONFIG.pointsPerDrop;

                    document.getElementById('score').textContent = this.score;

                    // æª¢æŸ¥æ˜¯å¦æ¸…ç©º
                    if (this.isGridEmpty()) {
                        this.level++;
                        document.getElementById('level').textContent = this.level;
                        this.sound.playLevelUp();

                        // æª¢æŸ¥æ˜¯å¦é€šé—œ
                        if (this.level > CONFIG.maxLevel) {
                            this.gameOver(true);
                            return;
                        }

                        this.addNewRows();
                    }
                }
            }

            removeFloatingBubbles() {
                // å¾é ‚éƒ¨æ‰¾æ‰€æœ‰é€£æ¥çš„æ³¡æ³¡
                const connected = new Set();

                // å¾ç¬¬ä¸€è¡Œé–‹å§‹ BFS
                for (let col = 0; col < CONFIG.cols; col++) {
                    if (this.grid[0] && this.grid[0][col]) {
                        const queue = [{ row: 0, col }];
                        connected.add(`0,${col}`);

                        while (queue.length > 0) {
                            const current = queue.shift();
                            const neighbors = this.getNeighbors(current.row, current.col);

                            for (const neighbor of neighbors) {
                                const key = `${neighbor.row},${neighbor.col}`;
                                if (!connected.has(key)) {
                                    connected.add(key);
                                    queue.push({ row: neighbor.row, col: neighbor.col });
                                }
                            }
                        }
                    }
                }

                // ç§»é™¤æ‰€æœ‰æœªé€£æ¥çš„æ³¡æ³¡
                let droppedCount = 0;
                const droppedBubbles = [];

                for (let row = 0; row < CONFIG.rows; row++) {
                    if (!this.grid[row]) continue;
                    for (let col = 0; col < CONFIG.cols; col++) {
                        if (this.grid[row][col] && !connected.has(`${row},${col}`)) {
                            // æ”¶é›†æ‰è½æ³¡æ³¡è³‡è¨Š
                            droppedBubbles.push({
                                x: this.grid[row][col].x,
                                y: this.grid[row][col].y,
                                color: this.grid[row][col].color
                            });
                            this.grid[row][col] = null;
                            droppedCount++;
                        }
                    }
                }

                // æ’­æ”¾æ‰è½éŸ³æ•ˆå’Œå‹•ç•«
                if (droppedCount > 0) {
                    this.sound.playDrop(droppedCount);
                    droppedBubbles.forEach((bubble, index) => {
                        setTimeout(() => {
                            this.particles.drop(bubble.x, bubble.y, bubble.color, 10);
                        }, index * 50);
                    });
                }

                return droppedCount;
            }

            isGridEmpty() {
                for (let row = 0; row < CONFIG.rows; row++) {
                    if (!this.grid[row]) continue;
                    for (let col = 0; col < CONFIG.cols; col++) {
                        if (this.grid[row][col]) return false;
                    }
                }
                return true;
            }

            addNewRows() {
                const newRows = 2;  // æ¯é—œæ–°å¢è¡Œæ•¸æ¸›å°‘ï¼ˆåŸæœ¬3ï¼‰
                for (let row = 0; row < newRows; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < CONFIG.cols; col++) {
                        const isOffsetRow = row % 2 === 1;
                        const maxCols = isOffsetRow ? CONFIG.cols - 1 : CONFIG.cols;

                        if (col < maxCols) {
                            const pos = this.getPositionFromGrid(row, col);
                            const color = BUBBLE_COLORS[Math.floor(Math.random() * BUBBLE_COLORS.length)];
                            this.grid[row][col] = new Bubble(pos.x, pos.y, color, row, col);
                        }
                    }
                }
            }

            draw() {
                // æ¸…ç©ºç•«å¸ƒ
                this.ctx.fillStyle = '#0a1628';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ç¹ªè£½èƒŒæ™¯æ ¼ç·š
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;
                for (let y = 0; y < this.canvas.height; y += 40) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // ç¹ªè£½ç¶²æ ¼ä¸­çš„æ³¡æ³¡
                for (let row = 0; row < CONFIG.rows; row++) {
                    if (!this.grid[row]) continue;
                    for (let col = 0; col < CONFIG.cols; col++) {
                        if (this.grid[row][col]) {
                            this.grid[row][col].draw(this.ctx);
                        }
                    }
                }

                // ç¹ªè£½ç„æº–ç·š
                if (!this.currentBubble?.isMoving) {
                    this.drawAimLine();
                }

                // ç¹ªè£½ç•¶å‰æ³¡æ³¡
                if (this.currentBubble) {
                    this.currentBubble.draw(this.ctx);
                }

                // ç¹ªè£½ç™¼å°„å™¨
                this.drawShooter();

                // ç¹ªè£½ç²’å­æ•ˆæœ
                this.particles.draw(this.ctx);
            }

            drawAimLine() {
                const startX = this.canvas.width / 2;
                const startY = CONFIG.shooterY;

                // è¨ˆç®—å°å¼•ç·šè·¯å¾‘ï¼ˆåŒ…å«åå½ˆï¼‰
                const path = this.calculateTrajectory(startX, startY, this.aimAngle);

                // ç¹ªè£½å°å¼•ç·š
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([8, 6]);

                this.ctx.beginPath();
                this.ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    this.ctx.lineTo(path[i].x, path[i].y);
                }
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // åœ¨è·¯å¾‘ä¸Šç¹ªè£½å°åœ“é»æ¨™è¨˜
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                const dotSpacing = 40;
                let traveled = 0;

                for (let i = 1; i < path.length; i++) {
                    const dx = path[i].x - path[i - 1].x;
                    const dy = path[i].y - path[i - 1].y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);
                    const segmentAngle = Math.atan2(dy, dx);

                    while (traveled < segmentLength) {
                        const dotX = path[i - 1].x + Math.cos(segmentAngle) * traveled;
                        const dotY = path[i - 1].y + Math.sin(segmentAngle) * traveled;

                        this.ctx.beginPath();
                        this.ctx.arc(dotX, dotY, 3, 0, Math.PI * 2);
                        this.ctx.fill();

                        traveled += dotSpacing;
                    }
                    traveled -= segmentLength;
                }

                // åœ¨çµ‚é»ç¹ªè£½é æ¸¬ä½ç½®çš„æ³¡æ³¡è¼ªå»“
                const endPoint = path[path.length - 1];
                if (endPoint.y < CONFIG.shooterY - 50) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.arc(endPoint.x, endPoint.y, CONFIG.bubbleRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }

            calculateTrajectory(startX, startY, angle) {
                const path = [{ x: startX, y: startY }];
                let x = startX;
                let y = startY;
                let vx = Math.cos(angle);
                let vy = Math.sin(angle);
                const step = 5;
                const maxLength = 800;
                let totalLength = 0;

                while (totalLength < maxLength && y > CONFIG.bubbleRadius) {
                    x += vx * step;
                    y += vy * step;
                    totalLength += step;

                    // æª¢æŸ¥å·¦å³é‚Šç•Œåå½ˆ
                    if (x <= CONFIG.bubbleRadius) {
                        x = CONFIG.bubbleRadius;
                        vx *= -1;
                        path.push({ x, y });
                    } else if (x >= this.canvas.width - CONFIG.bubbleRadius) {
                        x = this.canvas.width - CONFIG.bubbleRadius;
                        vx *= -1;
                        path.push({ x, y });
                    }

                    // æª¢æŸ¥æ˜¯å¦ç¢°åˆ°ç¾æœ‰æ³¡æ³¡
                    let hitBubble = false;
                    for (let row = 0; row < CONFIG.rows && !hitBubble; row++) {
                        if (!this.grid[row]) continue;
                        for (let col = 0; col < CONFIG.cols && !hitBubble; col++) {
                            const bubble = this.grid[row][col];
                            if (bubble) {
                                const dx = x - bubble.x;
                                const dy = y - bubble.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance < CONFIG.bubbleRadius * 2) {
                                    // æ‰¾åˆ°æœ€è¿‘çš„ç¶²æ ¼ä½ç½®
                                    const gridPos = this.getGridFromPosition(x, y);
                                    const snapPos = this.getPositionFromGrid(
                                        Math.max(0, Math.min(gridPos.row, CONFIG.rows - 1)),
                                        Math.max(0, gridPos.col)
                                    );
                                    path.push({ x: snapPos.x, y: snapPos.y });
                                    hitBubble = true;
                                }
                            }
                        }
                    }

                    if (hitBubble) break;

                    // æª¢æŸ¥é ‚éƒ¨é‚Šç•Œ
                    if (y <= CONFIG.bubbleRadius) {
                        y = CONFIG.bubbleRadius;
                        const gridPos = this.getGridFromPosition(x, y);
                        const snapPos = this.getPositionFromGrid(0, Math.max(0, gridPos.col));
                        path.push({ x: snapPos.x, y: snapPos.y });
                        break;
                    }
                }

                // å¦‚æœæ²’æœ‰ç¢°åˆ°ä»»ä½•æ±è¥¿ï¼Œæ·»åŠ æœ€å¾Œä¸€å€‹é»
                if (path.length === 1 || (path[path.length - 1].x !== x || path[path.length - 1].y !== y)) {
                    if (y > CONFIG.bubbleRadius) {
                        path.push({ x, y });
                    }
                }

                return path;
            }

            drawShooter() {
                const x = this.canvas.width / 2;
                const y = CONFIG.shooterY;

                // ç™¼å°„å™¨åº•åº§
                this.ctx.fillStyle = '#2d4a6f';
                this.ctx.beginPath();
                this.ctx.arc(x, y + 15, 35, 0, Math.PI * 2);
                this.ctx.fill();

                // ç™¼å°„å™¨ç®­é ­
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(this.aimAngle);

                this.ctx.fillStyle = '#4a7c9b';
                this.ctx.beginPath();
                this.ctx.moveTo(30, 0);
                this.ctx.lineTo(0, -10);
                this.ctx.lineTo(0, 10);
                this.ctx.closePath();
                this.ctx.fill();

                this.ctx.restore();

                // ç¹ªè£½ä¸‹ä¸€å€‹æ³¡æ³¡é è¦½ï¼ˆåœ¨å·¦å´ï¼‰
                if (this.nextBubble) {
                    // èƒŒæ™¯æ¡†
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(60, y - 25, 80, 50, 10);
                    this.ctx.fill();

                    // æ–‡å­—æ¨™ç±¤
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('ä¸‹ä¸€å€‹', 100, y - 8);

                    // ç¹ªè£½ä¸‹ä¸€å€‹æ³¡æ³¡
                    const previewBubble = new Bubble(100, y + 12, this.nextBubble.color);
                    previewBubble.radius = 16;
                    previewBubble.draw(this.ctx);
                }

                // ç¹ªè£½ç•¶å‰æ³¡æ³¡é¡è‰²æŒ‡ç¤ºï¼ˆåœ¨å³å´ï¼‰
                if (this.currentBubble && !this.currentBubble.isMoving) {
                    // èƒŒæ™¯æ¡†
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(this.canvas.width - 140, y - 25, 80, 50, 10);
                    this.ctx.fill();

                    // æ–‡å­—æ¨™ç±¤
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('ç•¶å‰', this.canvas.width - 100, y - 8);

                    // ç¹ªè£½ç•¶å‰æ³¡æ³¡é¡è‰²æŒ‡ç¤º
                    const currentPreview = new Bubble(this.canvas.width - 100, y + 12, this.currentBubble.color);
                    currentPreview.radius = 16;
                    currentPreview.draw(this.ctx);
                }
            }

            gameOver(isWin) {
                this.isGameOver = true;
                const overlay = document.getElementById('gameOverOverlay');
                const text = document.getElementById('gameOverText');
                const scoreDisplay = document.getElementById('finalScore');

                // æ’­æ”¾éŸ³æ•ˆ
                if (isWin) {
                    // é€šé—œæ…¶ç¥å‹•ç•«
                    this.particles.celebrate(this.canvas.width, this.canvas.height);
                    this.sound.playLevelUp();
                    // é¡å¤–æ’­æ”¾ä¸€æ¬¡æ…¶ç¥éŸ³æ•ˆï¼ˆå»¶é²ï¼‰
                    setTimeout(() => this.sound.playLevelUp(), 400);
                    setTimeout(() => this.sound.playLevelUp(), 800);
                } else {
                    this.sound.playGameOver();
                }

                // è¨­å®šçµæŸæ–‡å­—
                if (this.score > 0 && leaderboard.isHighScore(this.score)) {
                    text.textContent = isWin ? 'é€šé—œ + æ–°ç´€éŒ„ï¼' : 'æ–°ç´€éŒ„ï¼';
                    scoreDisplay.textContent = `åˆ†æ•¸: ${this.score} (ç¬¬ ${leaderboard.getRank(this.score)} å)`;
                } else {
                    text.textContent = isWin ? 'æ­å–œé€šé—œï¼å…¨éƒ¨ 5 é—œå®Œæˆï¼' : 'éŠæˆ²çµæŸ!';
                    scoreDisplay.textContent = `æœ€çµ‚åˆ†æ•¸: ${this.score}`;
                }

                // é€šé—œæ™‚å»¶é²é¡¯ç¤ºçµç®—ç•«é¢ï¼Œè®“ç©å®¶çœ‹æ…¶ç¥å‹•ç•«
                const showDelay = isWin ? 2000 : 0;

                setTimeout(() => {
                    overlay.classList.add('show');

                    // æª¢æŸ¥æ˜¯å¦å¯ä»¥ä¸Šæ’è¡Œæ¦œ
                    if (this.score > 0 && leaderboard.isHighScore(this.score)) {
                        setTimeout(() => {
                            showNameInput(this.score);
                        }, 500);
                    }
                }, showDelay);
            }

            restart() {
                this.init();
            }

            togglePause() {
                this.isPaused = !this.isPaused;
            }

            gameLoop() {
                this.update();
                // ç²’å­ç³»çµ±ç¨ç«‹æ›´æ–°ï¼ˆä¸å—æš«åœå½±éŸ¿ï¼‰
                this.particles.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // å•Ÿå‹•éŠæˆ²
        const game = new Game();

        // åˆå§‹åŒ–æœ€é«˜åˆ†é¡¯ç¤º
        updateHighScoreDisplay();

        // éŸ³æ•ˆé–‹é—œ
        function toggleSound() {
            const enabled = game.sound.toggle();
            document.getElementById('soundBtn').textContent = enabled ? 'éŸ³æ•ˆ: é–‹' : 'éŸ³æ•ˆ: é—œ';
        }
    </script>
</body>
</html>
